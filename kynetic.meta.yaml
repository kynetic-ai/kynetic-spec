# Kynetic Spec - Meta Manifest (Bootstrap)
# Process definitions extracted from AGENTS.md
#
# This is the initial bootstrap of meta-spec for dogfooding.
# As meta-spec implementation progresses, this will be validated
# and extended via CLI commands.

kynetic_meta: "1.0"

# =============================================================================
# AGENTS - Who works on this project
# =============================================================================
agents:
  - _ulid: 01KF782ZSF5ZQTN2PKZPH6ASKA
    id: claude
    name: Claude Code Agent
    description: |
      Primary AI development agent for kynetic-spec.
      Works via Claude Code CLI in terminal sessions.
    capabilities:
      - code
      - test
      - refactor
      - review
      - design
      - document
    tools:
      - kspec
      - git
      - npm
      - vitest
    session_protocol:
      start: "kspec session start"
      checkpoint: "kspec session checkpoint"
    conventions:
      - Always use kspec CLI, never edit YAML directly
      - Add notes when completing significant work
      - Check spec coverage before implementing behavior changes
      - Commit changes before ending session

# =============================================================================
# WORKFLOWS - How work is done
# =============================================================================
workflows:
  - _ulid: 01KF782ZSH8JG4CCJRWVQQ9G5R
    id: spec-first
    trigger: behavior-change
    description: |
      Check spec coverage before implementing changes.
      Core principle: If changing behavior and spec doesn't cover it,
      update the spec first.
    steps:
      - type: check
        content: Does the spec cover this change?
        on_fail: Update or create spec before proceeding
      - type: decision
        content: What is the spec status?
        options:
          - "Spec exists and matches -> Derive task, proceed"
          - "Spec exists but outdated -> Update spec first"
          - "No spec exists -> Create spec first (behavior) or task directly (infra)"
      - type: action
        content: Update or create spec item if needed
      - type: action
        content: Derive task from spec via kspec derive @spec-item
      - type: action
        content: Implement the change

  - _ulid: 01KF782ZSH103A99NV1VY65CFB
    id: session-start
    trigger: session-start
    description: |
      Get context at the beginning of a work session.
    steps:
      - type: action
        content: Run kspec session start to get context
      - type: check
        content: Are there active (in_progress) tasks?
        on_fail: Pick from ready tasks or triage inbox
      - type: action
        content: Review ready tasks and inbox items
      - type: action
        content: Start work on chosen task via kspec task start

  - _ulid: 01KF782ZSJH58GHDTHC873XJMA
    id: task-lifecycle
    trigger: task-complete
    description: |
      Complete a task properly with notes and cleanup.
    steps:
      - type: action
        content: Add completion note describing what was done
      - type: action
        content: Run kspec task complete @task --reason "summary"
      - type: check
        content: Are there uncommitted changes?
        on_fail: Commit changes with descriptive message
      - type: action
        content: Review if task unblocked other work

  - _ulid: 01KF782ZSJYAF3XCN89YD44XYM
    id: inbox-triage
    trigger: session-start
    description: |
      Triage inbox items during session context review.
    steps:
      - type: action
        content: Review oldest inbox items first
      - type: decision
        content: For each item, ask these questions
        options:
          - "Still relevant? No -> delete"
          - "Scope clear? Yes -> promote to task"
          - "Needs spec work? -> Create/update spec first"
          - "Still unclear? -> Leave, add tag, revisit later"
      - type: check
        content: Has item survived 3+ triage sessions?
        on_fail: Either promote with clear scope or delete

# =============================================================================
# CONVENTIONS - Project standards
# =============================================================================
conventions:
  - _ulid: 01KF782ZSJCXRCGV0QJ8Y9AKN2
    domain: commits
    rules:
      - Use conventional commit format (feat, fix, docs, refactor, test, chore)
      - Reference task in commit body when applicable
      - Keep subject line under 72 characters
      - Include Co-Authored-By for AI contributions
    examples:
      - good: "feat: add user login flow"
        bad: "Added login"
      - good: "fix(auth): handle expired tokens"
        bad: "fixed bug"

  - _ulid: 01KF782ZSJ20FHWEXH93VB74Q5
    domain: notes
    rules:
      - Add notes when completing significant work
      - Include what was done, approach taken, and why
      - Note any deviations from plan or unexpected findings
      - Keep notes concise but informative for future context
    examples:
      - good: "Implemented retry logic with exponential backoff. Chose 3 retries max based on API rate limits."
        bad: "Done"

  - _ulid: 01KF782ZSJZB6HWGFS01TM2R0R
    domain: naming
    rules:
      - Use kebab-case for slugs (task-user-login, not taskUserLogin)
      - Prefix task slugs with 'task-' for clarity
      - Use descriptive names that indicate purpose
      - Keep slugs short but unambiguous

  - _ulid: 01KF782ZSJ6HS09DBK7SVX5RR0
    domain: tags
    rules:
      - Use lowercase tags
      - Standard tags include mvp, post-mvp, bug, feature, infra, design
      - Add domain tags like cli, schema, parser, tasks
      - Limit to 3-5 tags per item for focus

# =============================================================================
# OBSERVATIONS - Feedback for self-improvement (initially empty)
# =============================================================================
# Observations will be added via:
#   kspec meta observe friction "description"
#   kspec meta observe success "description"
#
# This section bootstraps empty - friction and ideas captured during
# usage will populate it, enabling the self-improvement loop.
observations: []
